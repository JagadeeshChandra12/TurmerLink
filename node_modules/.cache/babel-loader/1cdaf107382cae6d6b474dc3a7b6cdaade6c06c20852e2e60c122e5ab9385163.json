{"ast":null,"code":"import CryptoJS from 'crypto-js';\n\n/**\r\n * Lightweight blockchain simulation for transaction verification\r\n * Creates hash-based ledger entries for tamper-proof storage\r\n */\n\nexport class BlockchainLedger {\n  constructor() {\n    this.chain = [];\n    this.difficulty = 2; // Simple proof of work\n  }\n\n  /**\r\n   * Create a new block with transaction data\r\n   */\n  createBlock(transactionData, previousHash = '') {\n    const block = {\n      index: this.chain.length,\n      timestamp: new Date().toISOString(),\n      data: transactionData,\n      previousHash: previousHash,\n      nonce: 0,\n      hash: ''\n    };\n\n    // Simple proof of work\n    block.hash = this.calculateHash(block);\n    while (!block.hash.startsWith('0'.repeat(this.difficulty))) {\n      block.nonce++;\n      block.hash = this.calculateHash(block);\n    }\n    return block;\n  }\n\n  /**\r\n   * Calculate hash for a block\r\n   */\n  calculateHash(block) {\n    const dataString = JSON.stringify({\n      index: block.index,\n      timestamp: block.timestamp,\n      data: block.data,\n      previousHash: block.previousHash,\n      nonce: block.nonce\n    });\n    return CryptoJS.SHA256(dataString).toString();\n  }\n\n  /**\r\n   * Add a new transaction to the ledger\r\n   */\n  addTransaction(transactionData) {\n    const previousHash = this.chain.length > 0 ? this.chain[this.chain.length - 1].hash : '';\n    const newBlock = this.createBlock(transactionData, previousHash);\n    this.chain.push(newBlock);\n    return newBlock;\n  }\n\n  /**\r\n   * Verify the integrity of the blockchain\r\n   */\n  verifyChain() {\n    for (let i = 1; i < this.chain.length; i++) {\n      const currentBlock = this.chain[i];\n      const previousBlock = this.chain[i - 1];\n\n      // Check if current block's previous hash matches previous block's hash\n      if (currentBlock.previousHash !== previousBlock.hash) {\n        return false;\n      }\n\n      // Check if current block's hash is valid\n      if (currentBlock.hash !== this.calculateHash(currentBlock)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\r\n   * Get transaction by hash\r\n   */\n  getTransactionByHash(hash) {\n    return this.chain.find(block => block.hash === hash);\n  }\n\n  /**\r\n   * Get all transactions for a farmer\r\n   */\n  getFarmerTransactions(farmerId) {\n    return this.chain.filter(block => block.data.farmerId === farmerId).map(block => ({\n      hash: block.hash,\n      timestamp: block.timestamp,\n      ...block.data\n    }));\n  }\n\n  /**\r\n   * Generate a transaction hash for verification\r\n   */\n  generateTransactionHash(transactionData) {\n    const dataString = JSON.stringify({\n      farmerId: transactionData.farmerId,\n      saleDate: transactionData.saleDate,\n      quantity: transactionData.quantity,\n      price: transactionData.price,\n      buyer: transactionData.buyer,\n      timestamp: new Date().toISOString()\n    });\n    return CryptoJS.SHA256(dataString).toString();\n  }\n}\n\n// Create a singleton instance\nexport const ledger = new BlockchainLedger();","map":{"version":3,"names":["CryptoJS","BlockchainLedger","constructor","chain","difficulty","createBlock","transactionData","previousHash","block","index","length","timestamp","Date","toISOString","data","nonce","hash","calculateHash","startsWith","repeat","dataString","JSON","stringify","SHA256","toString","addTransaction","newBlock","push","verifyChain","i","currentBlock","previousBlock","getTransactionByHash","find","getFarmerTransactions","farmerId","filter","map","generateTransactionHash","saleDate","quantity","price","buyer","ledger"],"sources":["C:/Turmerik Bits/src/utils/blockchain.js"],"sourcesContent":["import CryptoJS from 'crypto-js';\r\n\r\n/**\r\n * Lightweight blockchain simulation for transaction verification\r\n * Creates hash-based ledger entries for tamper-proof storage\r\n */\r\n\r\nexport class BlockchainLedger {\r\n  constructor() {\r\n    this.chain = [];\r\n    this.difficulty = 2; // Simple proof of work\r\n  }\r\n\r\n  /**\r\n   * Create a new block with transaction data\r\n   */\r\n  createBlock(transactionData, previousHash = '') {\r\n    const block = {\r\n      index: this.chain.length,\r\n      timestamp: new Date().toISOString(),\r\n      data: transactionData,\r\n      previousHash: previousHash,\r\n      nonce: 0,\r\n      hash: ''\r\n    };\r\n\r\n    // Simple proof of work\r\n    block.hash = this.calculateHash(block);\r\n    while (!block.hash.startsWith('0'.repeat(this.difficulty))) {\r\n      block.nonce++;\r\n      block.hash = this.calculateHash(block);\r\n    }\r\n\r\n    return block;\r\n  }\r\n\r\n  /**\r\n   * Calculate hash for a block\r\n   */\r\n  calculateHash(block) {\r\n    const dataString = JSON.stringify({\r\n      index: block.index,\r\n      timestamp: block.timestamp,\r\n      data: block.data,\r\n      previousHash: block.previousHash,\r\n      nonce: block.nonce\r\n    });\r\n    return CryptoJS.SHA256(dataString).toString();\r\n  }\r\n\r\n  /**\r\n   * Add a new transaction to the ledger\r\n   */\r\n  addTransaction(transactionData) {\r\n    const previousHash = this.chain.length > 0 ? this.chain[this.chain.length - 1].hash : '';\r\n    const newBlock = this.createBlock(transactionData, previousHash);\r\n    this.chain.push(newBlock);\r\n    return newBlock;\r\n  }\r\n\r\n  /**\r\n   * Verify the integrity of the blockchain\r\n   */\r\n  verifyChain() {\r\n    for (let i = 1; i < this.chain.length; i++) {\r\n      const currentBlock = this.chain[i];\r\n      const previousBlock = this.chain[i - 1];\r\n\r\n      // Check if current block's previous hash matches previous block's hash\r\n      if (currentBlock.previousHash !== previousBlock.hash) {\r\n        return false;\r\n      }\r\n\r\n      // Check if current block's hash is valid\r\n      if (currentBlock.hash !== this.calculateHash(currentBlock)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get transaction by hash\r\n   */\r\n  getTransactionByHash(hash) {\r\n    return this.chain.find(block => block.hash === hash);\r\n  }\r\n\r\n  /**\r\n   * Get all transactions for a farmer\r\n   */\r\n  getFarmerTransactions(farmerId) {\r\n    return this.chain\r\n      .filter(block => block.data.farmerId === farmerId)\r\n      .map(block => ({\r\n        hash: block.hash,\r\n        timestamp: block.timestamp,\r\n        ...block.data\r\n      }));\r\n  }\r\n\r\n  /**\r\n   * Generate a transaction hash for verification\r\n   */\r\n  generateTransactionHash(transactionData) {\r\n    const dataString = JSON.stringify({\r\n      farmerId: transactionData.farmerId,\r\n      saleDate: transactionData.saleDate,\r\n      quantity: transactionData.quantity,\r\n      price: transactionData.price,\r\n      buyer: transactionData.buyer,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    return CryptoJS.SHA256(dataString).toString();\r\n  }\r\n}\r\n\r\n// Create a singleton instance\r\nexport const ledger = new BlockchainLedger();\r\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,WAAW;;AAEhC;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,gBAAgB,CAAC;EAC5BC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC,CAAC;EACvB;;EAEA;AACF;AACA;EACEC,WAAWA,CAACC,eAAe,EAAEC,YAAY,GAAG,EAAE,EAAE;IAC9C,MAAMC,KAAK,GAAG;MACZC,KAAK,EAAE,IAAI,CAACN,KAAK,CAACO,MAAM;MACxBC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;MACnCC,IAAI,EAAER,eAAe;MACrBC,YAAY,EAAEA,YAAY;MAC1BQ,KAAK,EAAE,CAAC;MACRC,IAAI,EAAE;IACR,CAAC;;IAED;IACAR,KAAK,CAACQ,IAAI,GAAG,IAAI,CAACC,aAAa,CAACT,KAAK,CAAC;IACtC,OAAO,CAACA,KAAK,CAACQ,IAAI,CAACE,UAAU,CAAC,GAAG,CAACC,MAAM,CAAC,IAAI,CAACf,UAAU,CAAC,CAAC,EAAE;MAC1DI,KAAK,CAACO,KAAK,EAAE;MACbP,KAAK,CAACQ,IAAI,GAAG,IAAI,CAACC,aAAa,CAACT,KAAK,CAAC;IACxC;IAEA,OAAOA,KAAK;EACd;;EAEA;AACF;AACA;EACES,aAAaA,CAACT,KAAK,EAAE;IACnB,MAAMY,UAAU,GAAGC,IAAI,CAACC,SAAS,CAAC;MAChCb,KAAK,EAAED,KAAK,CAACC,KAAK;MAClBE,SAAS,EAAEH,KAAK,CAACG,SAAS;MAC1BG,IAAI,EAAEN,KAAK,CAACM,IAAI;MAChBP,YAAY,EAAEC,KAAK,CAACD,YAAY;MAChCQ,KAAK,EAAEP,KAAK,CAACO;IACf,CAAC,CAAC;IACF,OAAOf,QAAQ,CAACuB,MAAM,CAACH,UAAU,CAAC,CAACI,QAAQ,CAAC,CAAC;EAC/C;;EAEA;AACF;AACA;EACEC,cAAcA,CAACnB,eAAe,EAAE;IAC9B,MAAMC,YAAY,GAAG,IAAI,CAACJ,KAAK,CAACO,MAAM,GAAG,CAAC,GAAG,IAAI,CAACP,KAAK,CAAC,IAAI,CAACA,KAAK,CAACO,MAAM,GAAG,CAAC,CAAC,CAACM,IAAI,GAAG,EAAE;IACxF,MAAMU,QAAQ,GAAG,IAAI,CAACrB,WAAW,CAACC,eAAe,EAAEC,YAAY,CAAC;IAChE,IAAI,CAACJ,KAAK,CAACwB,IAAI,CAACD,QAAQ,CAAC;IACzB,OAAOA,QAAQ;EACjB;;EAEA;AACF;AACA;EACEE,WAAWA,CAAA,EAAG;IACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC1B,KAAK,CAACO,MAAM,EAAEmB,CAAC,EAAE,EAAE;MAC1C,MAAMC,YAAY,GAAG,IAAI,CAAC3B,KAAK,CAAC0B,CAAC,CAAC;MAClC,MAAME,aAAa,GAAG,IAAI,CAAC5B,KAAK,CAAC0B,CAAC,GAAG,CAAC,CAAC;;MAEvC;MACA,IAAIC,YAAY,CAACvB,YAAY,KAAKwB,aAAa,CAACf,IAAI,EAAE;QACpD,OAAO,KAAK;MACd;;MAEA;MACA,IAAIc,YAAY,CAACd,IAAI,KAAK,IAAI,CAACC,aAAa,CAACa,YAAY,CAAC,EAAE;QAC1D,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACEE,oBAAoBA,CAAChB,IAAI,EAAE;IACzB,OAAO,IAAI,CAACb,KAAK,CAAC8B,IAAI,CAACzB,KAAK,IAAIA,KAAK,CAACQ,IAAI,KAAKA,IAAI,CAAC;EACtD;;EAEA;AACF;AACA;EACEkB,qBAAqBA,CAACC,QAAQ,EAAE;IAC9B,OAAO,IAAI,CAAChC,KAAK,CACdiC,MAAM,CAAC5B,KAAK,IAAIA,KAAK,CAACM,IAAI,CAACqB,QAAQ,KAAKA,QAAQ,CAAC,CACjDE,GAAG,CAAC7B,KAAK,KAAK;MACbQ,IAAI,EAAER,KAAK,CAACQ,IAAI;MAChBL,SAAS,EAAEH,KAAK,CAACG,SAAS;MAC1B,GAAGH,KAAK,CAACM;IACX,CAAC,CAAC,CAAC;EACP;;EAEA;AACF;AACA;EACEwB,uBAAuBA,CAAChC,eAAe,EAAE;IACvC,MAAMc,UAAU,GAAGC,IAAI,CAACC,SAAS,CAAC;MAChCa,QAAQ,EAAE7B,eAAe,CAAC6B,QAAQ;MAClCI,QAAQ,EAAEjC,eAAe,CAACiC,QAAQ;MAClCC,QAAQ,EAAElC,eAAe,CAACkC,QAAQ;MAClCC,KAAK,EAAEnC,eAAe,CAACmC,KAAK;MAC5BC,KAAK,EAAEpC,eAAe,CAACoC,KAAK;MAC5B/B,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IACpC,CAAC,CAAC;IACF,OAAOb,QAAQ,CAACuB,MAAM,CAACH,UAAU,CAAC,CAACI,QAAQ,CAAC,CAAC;EAC/C;AACF;;AAEA;AACA,OAAO,MAAMmB,MAAM,GAAG,IAAI1C,gBAAgB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}